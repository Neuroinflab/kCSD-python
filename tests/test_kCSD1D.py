'''
This script is used to test the Current Source Density Estimates,
using the kCSD method Potworowski et.al (2012) for 1D case

This script is in alpha phase.

This was written by:
Michal Czerwinski, Chaitanya Chintaluri,
Laboratory of Neuroinformatics,
Nencki Institute of Exprimental Biology, Warsaw.
'''
from __future__ import print_function, division
import time
import os
import sys
sys.path.append('..')

import numpy as np
from scipy.interpolate import interp1d
from scipy.integrate import simps
import matplotlib.pyplot as plt

import csd_profile as CSD 
from KCSD1D import KCSD1D

def generate_csd_1D(csd_profile, csd_seed, start_x=0., end_x=1., res_x=50):
    """
    Gives CSD profile at the requested spatial location, at 'res' resolution
    """
    chrg_pos_x = np.linspace(start_x, end_x, res_x)
    f = csd_profile(chrg_pos_x, seed=csd_seed)
    return chrg_pos_x, f

def grid(x, z, resX=100):
    """
    Convert 2 column data to two (2) matplotlib axes to plot, interpolates to given resolution using scipy.interp1d
    """
    z = z.flatten()
    xi = np.linspace(min(x), max(x), resX)
    X = x.flatten()
    f = interp1d(X,z)
    Y = f(xi)
    return xi, Y

def generate_electrodes(xlims=[0.1,0.9], res=5):
    """
    Places electrodes lineary
    """
    ele_x= np.linspace(xlims[0], xlims[1], res)
    ele_x = ele_x.flatten()
    return ele_x

def generate_csd_space(xlims=[0.0,1.0], gdX=0.01):
    """
    Area of interest for the CSD reconstruction
    """
    nx = (xlims[1] - xlims[0])/gdX
    space_X = np.linspace(xlims[0], xlims[1], nx)
    return space_X

def make_plots(title, 
               chrg_x, csd, 
               ele_x, pots, 
               csd_x, est_csd, est_pot, 
               true_pot=None):
    """
    Shows 2 subplots
    1_a true CSD generated based on the random seed given
    1_b kernel CSD the output of this method
    2_a pots - true potentials, generated by simpsons rule integration
    2_b Kernel interpolated LFP, 
    """
    fig = plt.figure(figsize=(7,10))
    #CSDs
    ax1 = plt.subplot(211)
    if np.array(csd_x).any() != False:
        im1b = ax1.plot(csd_x, est_csd[:,0], 'r', label='kCSD', linewidth=3)
    im1a = ax1.plot(chrg_x, csd, 'g', label = 'CSD', linestyle='--', linewidth=3)
    ax1.plot(ele_x, np.zeros_like(ele_x), 'ko',markersize=2.)
    plt.legend() 
    ax1.set_xlim([0.,1.])
    #ax1.set_ylim(ax1.get_ylim()[::-1]) #Zero on the top --ASK?!
    max_csd = np.maximum(max(np.abs(csd)), max(np.abs(est_csd[:,0])))
    max_csd += max_csd*0.2
    ax1.set_ylim([-max_csd, max_csd])
    ax1.set_xlabel('Depth mm')
    ax1.set_ylabel('CSD mA/mm')
    #Potentails
    ax2 = plt.subplot(212)
    ax2.plot( ele_x, np.zeros_like(ele_x),'ko',markersize=2.)
    im2b = ax2.plot(csd_x, est_pot, 'b', label = 'kPOT', linewidth=3)
    im2a = ax2.plot(chrg_x,true_pot, color = 'orange', 
                    linestyle='--', label='TruePOT', linewidth=3)
    ax2.set_xlim([0.,1.])
    #ax2.set_ylim(ax2.get_ylim()[::-1]) #Zero on the top --ASK?!
    ax2.plot(ele_x, pots, 'kx', markersize=8.)
    max_pots = np.maximum(max(np.abs(true_pot)), max(np.abs(est_pot)))
    max_pots += max_pots*0.2
    ax2.set_xlabel('Depth mm')
    ax2.set_ylabel('Potential mV')
    ax2.set_ylim([-max_pots, max_pots])
    fig.suptitle(title)
    plt.legend()
    plt.show()
    return 

def integrate_1D(x0, csd_x, csd, h):
    m = np.sqrt((csd_x-x0)**2 + h**2) - abs(csd_x-x0)
    y = csd * m 
    I = simps(y, csd_x)
    return I

def calculate_potential_1D(csd, measure_locations, csd_space_x, h):
    sigma = 1.0
    pots = np.zeros(len(measure_locations))
    for ii in range(len(measure_locations)):
        pots[ii] = integrate_1D(measure_locations[ii], csd_space_x, csd, h)
    pots *= 1/(2.*sigma) #eq.: 26 from Potworowski et al
    return pots

def electrode_config(ele_lims, ele_res, true_csd, t_csd_x, h):
    """
    creates electrodes positions, and potentials on them
    electrode lims, electrode resolution, profile, states
    """
    ele_x = generate_electrodes(ele_lims, ele_res)
    pots = calculate_potential_1D(true_csd, ele_x, t_csd_x, h)
    ele_pos = ele_x.reshape((len(ele_x), 1))
    return ele_pos, pots

def do_kcsd(ele_pos, pots, **params):
    """
    Function that calls the KCSD2D module
    """
    num_ele = len(ele_pos)
    pots = pots.reshape(num_ele, 1)
    k = KCSD1D(ele_pos, pots, **params)
    #k.cross_validate(Rs=np.arange(0.01,0.2,0.01), lambdas= np.logspace(15,-25,25))
    k.cross_validate(Rs=np.array([0.275]), lambdas=np.logspace(15,-25, 35))
    est_csd = k.values()
    est_pot =  k.values('POT')
    return k, est_csd, est_pot

def main_loop(csd_profile, csd_seed, total_ele):
    """
    Loop that decides the random number seed for the CSD profile,
    electrode configurations and etc.
    """
    if sys.version_info < (3,0):
        csd_name = csd_profile.func_name
    else:
        csd_name = csd_profile.__name__
    print('Using sources %s - Seed: %d ' % (csd_name, csd_seed))
    h = 10.

    #TrueCSD
    start_x, end_x, csd_res = [0.,1.,100]    
    t_csd_x, true_csd = generate_csd_1D(csd_profile, csd_seed, 
                                        start_x=start_x, 
                                        end_x=end_x, 
                                        res_x=csd_res)
    
    #Electrodes 
    ele_res = int(total_ele) 
    ele_lims = [0.10, 0.9]
    ele_pos, pots = electrode_config(ele_lims, ele_res, true_csd, t_csd_x, h)
    num_ele = ele_pos.shape[0]
    print('Number of electrodes:', num_ele)
    x_array_pots, true_pots = electrode_config(ele_lims, 100, true_csd, t_csd_x, h)

    #kCSD estimation
    gdX = 0.01
    x_lims = [0.,1.] #CSD estimation place
    tic = time.time() #time it
    k, est_csd, est_pot = do_kcsd(ele_pos, pots, h=h, gdx=gdX,
                                  xmin=x_lims[0], xmax=x_lims[1], n_src_init=300)
    toc = time.time() - tic

    #RMS of estimation - gives estimate of how good the reconstruction was
    chr_x, test_csd = generate_csd_1D(csd_profile, csd_seed,
                                      start_x=x_lims[0], end_x=x_lims[1], 
                                      res_x=int((x_lims[1]-x_lims[0])/gdX))
    rms = np.linalg.norm(abs(test_csd - est_csd[:,0]))
    rms /= np.linalg.norm(test_csd)

    #Plots
    title ="Lambda: %0.2E; R: %0.2f; CV_Error: %0.2E; RMS_Error: %0.2E; Time: %0.2f" %(k.lambd, k.R, k.cv_error, rms, toc)
    make_plots(title, t_csd_x, true_csd, ele_pos, pots, k.estm_x, est_csd, est_pot, true_pots)
    return

def test_calculating_potentials(csd_seed):
    csd_profile = CSD.gauss_1d_mono
    plt.figure('csd')
    _csdx = np.linspace(0,1,100)
    plt.plot(_csdx, CSD.gauss_1d_mono(_csdx, csd_seed))
    #constant measure_locations, constant csd_space_lims, different csd resolution
    plt.figure('changing csd res')
    for i in range(5):    
        csdres = 10+i*10
        (x, V) = electrode_config([0.,1.], 1000, csd_profile, [0.,1.], csd_seed, CSDres=csdres)
        #ans = calculate_potential_1D(csd_profile, measure_locations, states, csd_space_lims=[0.,1.], CSDres=csdres)    
        plt.plot(x, V, label=str(csdres))
    plt.legend()
    #changing olny measure resolution
    #measure_locations = np.arange(0,1,1000)
    plt.figure('changing measure res')
    for i in range(5):    
        measure_res= 20+i*50
        (x, V) = electrode_config([0.,1.], measure_res, csd_profile, [0.,1.], csd_seed, CSDres=1000)
        plt.plot(x,V, ms = 0.5, label =str(measure_res))
    plt.legend()
    plt.show()
    return

if __name__=='__main__':
    total_ele = 30
    csd_seed = 11
    csd_profile = CSD.gauss_1d_mono
    #test_calculating_potentials(csd_seed)
    a = main_loop(csd_profile, csd_seed, total_ele)
    #fig.savefig(os.path.join(plots_folder, save_as+'.png'))
    #plt.clf()
    #plt.close()
